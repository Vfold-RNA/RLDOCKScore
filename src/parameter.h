#pragma once

#include <limits>
#include <cmath>
#include <vector>
#include <array>
#include <map>
#include <string>

#include "common.h"
#include "vec3d.h"
#include "matrix.h"

namespace rlscore {

struct Parameter {
    // multiply pK by this to get free energy in kcal/mol:
    // K = exp(E/RT)  -- lower K and lower E == better binder
    // pK = -log10(K)   => K = 10^(-pK)
    // E = RT ln(K) = RT ln (10^(-pK)) = - RT * ln(10) * pK
    // const Float pK_to_energy_factor = -8.31 /* RT in J/K/mol */ * 0.001 /* kilo */ * 300 /* K */ / 4.184 /* J/cal */ * std::log(10.0); //  -0.6 kcal/mol * log(10) = -1.38
    // inline const Float pK_to_energy(Float pK) { return pK_to_energy_factor * pK; } //return the energy from give pK

    const Float T = 25.0; // system temperature
    const Float rt_to_kcal_per_mol = 0.593*(273+T)/(273+25); // 1 mol of kT = 1 RT = 0.593 kcal/mol for T = 298K

    const Float eps_rna = 20.0; // dielectric constants used for RNA and ligand
    const Float eps_h2o = (87.740-0.4008*T+9.398*1e-4*T*T-1.41*1e-6*T*T*T); // dielectric constnats used for water 78.28534375
    const Float lb0 = 7.15*(273+25)*(87.740-0.4008*25+9.398*1e-4*25*25-1.41*1e-6*25*25*25)/(273+T) * rt_to_kcal_per_mol; // lb0=e^2/(4*pi*eps0*Kb*T) * rt_to_kcal_per_mol, in Å*kcal/mol, multiply with 1/r gives energy in kcal/mol
    // 0H   1C   2N    3O    4P   5S    6other
    #ifdef MODE_TEST
    const Floats radii = {1.50, 1.50, 1.50, 1.50, 1.50, 1.50, 1.50};
    const Floats born_scales = {0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85};
    #else
    const Floats radii = {1.0, 1.7, 1.65, 1.5, 1.9, 1.80, 1.7};
    const Floats born_scales = {0.85, 0.72, 0.79, 0.85, 0.86, 0.80, 0.72};
    #endif

    // const Float debye_scale = 0.73;
    // const Float debye_length = std::sqrt(78.5*298/0.1) * 0.01988453199; // debye length = sqrt(eps_r*T/C0) * sqrt(eps_0*R/(2*10^3*F^2)), see wiki, https://en.wikipedia.org/wiki/Debye_length, C0 is the electrolyte concentration in molar units (M or mol/L)
    // const Float bulk_concentration = 0.1; // M (mol/L)
    // const Float debye_length = std::sqrt(eps_h2o*(273+T)/bulk_concentration) * 0.01988453199; // debye length = sqrt(eps_r*T/C0) * sqrt(eps_0*R/(2*10^3*F^2)), see wiki, https://en.wikipedia.org/wiki/Debye_length, C0 is the electrolyte concentration in molar units (M or mol/L),  [ 9.604256213 Å for 0.1 M ]
    // const Float debye_scale = 0.7310001348; // effective debye length = debye_length/debye_scale,
    // const Float debye_kappa = debye_scale/debye_length; // 0.07611210265 for default value

    const Float debye_length = k_not_a_num;
    const Float debye_kappa = k_not_a_num;

    const Size_Type LJstep = 1000;
    const Float LJ_cut = 2.50;
    const Float equ_LJ =  0.8;
    const Float excludLJ = 0.6;
    const Float eps_LJ = 0.1; // well depth for LJ in kcal/mol, rough estimate, see rDock user guide, table 13.1, Tripos 5.2 force field

    const Float Hbond_max = 1.3;
    const Float Hbond_min = 0.8;
    const Float eps_Hbond = 1.0; // well depth for Hbond in kcal/mol, rough estimate

    const Float gamma_SASA =  0.0054;
    #ifdef MODE_TEST
    const Float r_water =  1.3;
    #else
    const Float r_water =  1.4;
    #endif
    // const Float step_SASA = 0.25;

    // tables generated by the constructor
    // std::vector<std::vector<std::vector<Float>>> lj_table;
    Matrix<Floats> lj_table;
    // std::vector<std::vector<std::vector<Float>>> hbond_table;
    Matrix<Floats> hbond_table;
    // std::vector<std::vector<std::vector<std::vector<Float>>>> sasa_table;
    std::vector<std::vector<Vec3d>> sasa_points;
    // std::array<Matrix<Floats>, this->radii.size()> sasa_table = ;

    //3.125-5.875
    const Float stack_scale = 0.1;
    const Float stack_lower_bound = 3.125;
    const Float stack_upper_bound = 5.875;
    const Float stack_step = 0.25;
    const std::vector<Float> CC_stack_score = {1.190, -0.106, -0.579, -0.462, -0.655, -0.343, -0.373, -0.369, -0.192, 0.002, -0.054, -0.034};
    const std::vector<Float> CN_stack_score = {0.809, -0.348, -0.760, -0.647, -0.691, -0.425, -0.305, -0.322, -0.358, -0.172, -0.149, -0.007};
    const std::vector<Float> NC_stack_score = {1.014, -0.325, -0.890, -0.807, -0.323, -0.406, -0.289, -0.297, -0.296, -0.214, -0.273, -0.015};
    const std::vector<Float> NN_stack_score = {0.940, -0.399, -1.001, -0.709, -0.513, -0.448, -0.549, -0.607, -0.379, -0.029, 0.103, -0.039};

    Parameter(const Float dl) : debye_length(dl), debye_kappa(1.0/dl) {
        this->lj_table = Matrix<Floats>(this->radii.size(), this->radii.size(), Floats(this->LJstep+1, 0.0));
        this->hbond_table = Matrix<Floats>(this->radii.size(), this->radii.size(), Floats(this->LJstep+1, 0.0));

        this->generate_lj_table();
        this->generate_hbond_table();
        this->generate_sasa_table();
    }

  private:
    void generate_lj_table() {
        Size_Type Nstep,istep;
        Float dis,rdis,dr;
        Float dx,x6;
        for(Size_Type i = 0; i != this->radii.size(); i++) {
            for(Size_Type j = i; j != this->radii.size(); j++) {
                rdis = (this->radii[i] + this->radii[j])*this->equ_LJ;
                dr = this->LJ_cut * (this->radii[i] + this->radii[j]) / this->LJstep;
                for(Size_Type istep = 1; istep <= this->LJstep; istep++) {
                    dis = istep*dr;
                    dx = rdis/dis;
                    x6 = dx*dx*dx*dx*dx*dx;
                    this->lj_table(i, j)[istep]=eps_LJ*(x6*x6-x6);
                    this->lj_table(j, i)[istep]=this->lj_table(i, j)[istep];
                    //   if(j==8)
                    //   printf("%d %d %d %lf %lf \n",i,j,istep,dis,LJpotential(i, j)[istep]);
                } // end for istep
            } // end for j
        } // end for i
        //  exit(2);
    } // end function
    void generate_hbond_table() {
        for(Size_Type i = 0; i != this->radii.size(); i++) {
            for(Size_Type j = i; j != this->radii.size(); j++) {
                Float dismax = this->Hbond_max * (this->radii[i]+this->radii[j]);
                Float dismin = this->Hbond_min * (this->radii[i]+this->radii[j]);
                Float dr = dismax/this->LJstep;
                for(Size_Type istep = 1; istep <= this->LJstep; istep++) {
                    Float dis = dr*istep;
                    if(dis > dismin) {
                        this->hbond_table(i, j)[istep] = eps_Hbond * (1.0-(dis-dismin)/(dismax-dismin));
                        this->hbond_table(j, i)[istep] = this->hbond_table(i, j)[istep];
                        } else {
                            this->hbond_table(i, j)[istep] = eps_Hbond*1.0;
                            this->hbond_table(j, i)[istep] = eps_Hbond*1.0;
                    }
                }
            }
        }
    }
    void generate_sasa_table() {
        //Golden section spiral to generate quasi-uniformly distributed points on sphere
        //http://web.archive.org/web/20120421191837/http://www.cgafaq.info/wiki/Evenly_distributed_points_on_sphere
        //prepare_sasa_lookup
        this->sasa_points.resize(this->radii.size(), std::vector<Vec3d>());
        for(Size_Type i = 0; i != this->radii.size(); i++) {
            const Float rr = this->radii[i]+this->r_water;
            const Size_Type unit_N = 1000; // num of test points for unit sphere
            // num of test points for the atom
            const Size_Type N = unit_N * rr * rr;
            this->sasa_points[i] = std::vector<Vec3d>(N);
            const Float dphi = k_pi * (3.0 - std::sqrt(5.0)); // golden section?
            const Float dz = 2.0 / N; // increments in z direction
            Float phi = 0.0;
            Float z = 1.0 - dz / 2.0;
            std::vector<Vec3d>& points = this->sasa_points[i];
            for(Size_Type i = 0; i < N; i++) {
                const Float r = std::sqrt(1.0 - z * z);
                points[i] = Vec3d(std::cos(phi)*r, std::sin(phi)*r, z) * rr;
                z -= dz;
                phi += dphi;
            }
        }
    }
};

}